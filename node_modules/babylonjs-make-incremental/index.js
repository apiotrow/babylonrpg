"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Converted to JS from https://github.com/BabylonJS/Babylon.js/tree/master/Tools/MakeIncremental
 */
var path_1 = require("path");
var fs_1 = require("fs");
function makeIncremental(src, options) {
    if (options === void 0) { options = {}; }
    if (!src) {
        throw new Error("No source directory provided. Please pass src in the options, e.g. /scene");
    }
    var parsedSrc = fixSeparators(src);
    var parsedOptions = {
        excludedPaths: (options.excludedPaths || []).map(fixSeparators),
        excludedMeshes: (options.excludedMeshes || {}),
    };
    searchBabylonFiles(parsedSrc, parsedSrc, parsedOptions);
}
exports.default = makeIncremental;
function searchBabylonFiles(root, currentPath, options) {
    fs_1.readdirSync(currentPath).forEach(function (file) {
        var filePath = path_1.join(currentPath, file);
        var relativePath = trimSeparators(filePath.replace(root, ""));
        var babylonExtension = ".babylon";
        if (options.excludedPaths.indexOf(relativePath) >= 0) {
            return;
        }
        if (fs_1.statSync(filePath).isDirectory()) {
            searchBabylonFiles(root, filePath, options);
        }
        else if (file.indexOf(babylonExtension) > 0
            && file.indexOf(babylonExtension) === file.length - babylonExtension.length) {
            var scene = JSON.parse(fs_1.readFileSync(filePath).toString());
            var filename_1 = file.substr(0, file.lastIndexOf("."));
            scene.autoClear = true;
            scene.useDelayedTextureLoading = true;
            var doNotDelayLoadingForGeometries_1 = [];
            var excludedMeshes_1 = options.excludedMeshes[relativePath] || [];
            // Parsing meshes
            scene.meshes.forEach(function (mesh) {
                if (!excludedMeshes_1.some(function (meshCheck) { return meshCheck.test(mesh.name); })) {
                    // Do not delay load collisions object
                    if (mesh.checkCollisions) {
                        if (mesh.geometryId) {
                            doNotDelayLoadingForGeometries_1.push(mesh.geometryId);
                        }
                    }
                    else {
                        extract(mesh, currentPath, filename_1, true);
                    }
                }
            });
            // Parsing vertexData
            var geometries = scene.geometries;
            if (geometries) {
                var vertexData = geometries.vertexData;
                vertexData.forEach(function (geometry) {
                    var id = geometry.id;
                    if (!doNotDelayLoadingForGeometries_1.some(function (g) { return g === id; })) {
                        extract(geometry, currentPath, filename_1, false);
                    }
                });
            }
            // Saving
            var outputPath = filename_1 + ".incremental.babylon";
            var json = JSON.stringify(scene, null, 0);
            fs_1.writeFileSync(path_1.join(currentPath, outputPath), json);
        }
    });
}
function extract(meshOrGeometry, outputDir, filename, mesh) {
    if (mesh === void 0) { mesh = true; }
    // tslint:disable-next-line:no-console
    console.log("Extracting " + (mesh ? meshOrGeometry.name : meshOrGeometry.id));
    if (meshOrGeometry.positions && meshOrGeometry.normals && meshOrGeometry.indices) {
        meshOrGeometry.delayLoadingFile = createDelayLoadingFile(meshOrGeometry, outputDir, filename, mesh);
        // tslint:disable-next-line:no-console
        console.log("Delay loading file: " + meshOrGeometry.delayLoadingFile);
        // Compute bounding boxes
        var positions = meshOrGeometry.positions.map(function (v) { return parseFloat(v); });
        var minimum = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
        var maximum = [Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE];
        for (var index = 0; index < positions.length; index += 3) {
            var x = positions[index];
            var y = positions[index + 1];
            var z = positions[index + 2];
            if (x < minimum[0]) {
                minimum[0] = x;
            }
            if (x > maximum[0]) {
                maximum[0] = x;
            }
            if (y < minimum[1]) {
                minimum[1] = y;
            }
            if (y > maximum[1]) {
                maximum[1] = y;
            }
            if (z < minimum[2]) {
                minimum[2] = z;
            }
            if (z > maximum[2]) {
                maximum[2] = z;
            }
        }
        meshOrGeometry.boundingBoxMinimum = minimum;
        meshOrGeometry.boundingBoxMaximum = maximum;
        // Erasing infos
        meshOrGeometry.positions = null;
        meshOrGeometry.normals = null;
        meshOrGeometry.indices = null;
        if (meshOrGeometry.uvs) {
            meshOrGeometry.hasUVs = true;
            meshOrGeometry.uvs = null;
        }
        if (meshOrGeometry.uvs2) {
            meshOrGeometry.hasUVs2 = true;
            meshOrGeometry.uvs2 = null;
        }
        if (meshOrGeometry.colors) {
            meshOrGeometry.hasColors = true;
            meshOrGeometry.colors = null;
        }
        if (meshOrGeometry.matricesIndices) {
            meshOrGeometry.hasMatricesIndices = true;
            meshOrGeometry.matricesIndices = null;
        }
        if (meshOrGeometry.matricesWeights) {
            meshOrGeometry.hasMatricesWeights = true;
            meshOrGeometry.matricesWeights = null;
        }
        if (mesh && meshOrGeometry.subMeshes) {
            meshOrGeometry.subMeshes = null;
        }
    }
}
function createDelayLoadingFile(meshOrGeometry, outputDir, filename, mesh) {
    if (mesh === void 0) { mesh = true; }
    var encodedName = (mesh ? meshOrGeometry.name : meshOrGeometry.id).replace("+", "_").replace(" ", "_");
    var outputPath = filename + "." + encodedName + (mesh ? ".babylonmeshdata" : ".babylongeometrydata");
    var result = {
        positions: meshOrGeometry.positions,
        indices: meshOrGeometry.indices,
        normals: meshOrGeometry.normals,
    };
    if (meshOrGeometry.uvs) {
        result.uvs = meshOrGeometry.uvs;
    }
    if (meshOrGeometry.uvs2) {
        result.uvs2 = meshOrGeometry.uvs2;
    }
    if (meshOrGeometry.colors) {
        result.colors = meshOrGeometry.colors;
    }
    if (meshOrGeometry.matricesIndices) {
        result.matricesIndices = meshOrGeometry.matricesIndices;
    }
    if (meshOrGeometry.matricesWeights) {
        result.matricesWeights = meshOrGeometry.matricesWeights;
    }
    if (mesh && meshOrGeometry.subMeshes) {
        result.subMeshes = meshOrGeometry.subMeshes;
    }
    var json = JSON.stringify(result, null, 0);
    fs_1.writeFileSync(path_1.join(outputDir, outputPath), json);
    return encodeURIComponent(outputPath.split(path_1.sep).pop());
}
function fixSeparators(path) {
    return trimSeparators(path.replace("/", path_1.sep).replace("\\", path_1.sep));
}
function trimSeparators(path) {
    return path.split(path_1.sep).filter(function (s) { return s && s !== "."; }).join(path_1.sep);
}
if (module && module.hasOwnProperty("exports")) {
    module.exports = makeIncremental;
}
